using System;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Client.ConsoleWrappers;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Models.Messages;
using Shared.Models.Responses;
using System.Collections.Generic;

namespace Client
{
    //Класс для непосредственной работы с сейтью. Он занимается отправкой и приемом данных
    //Используя его извне можно не думать о том, как именно передаются данные
    public class NetworkWrapper
    {
        //объект TCP клиента для подключения к серверу по протоколу TCP
        private readonly TcpClient tcpClient = new TcpClient();
        //Объект синхронизации, для того чтобы при отправке сообщений не могло проихойти коллизии.
        //Испольлзуется ниже в этом файле
        private readonly object sync = new object();
        //tokenSource управляет токенами завершения работы потоков.
        //Данный класс будет инициировать два потока, и нам надо будет их как то остановить
        private readonly CancellationTokenSource tokenSource = new CancellationTokenSource();

        //Событие ResponseRecieved
        //Событие - возможность языка C# вызывать какие-то методы или лямбды
        //В тот момент, когда это понадобится. То есть когда мы создали NetworkWrapper
        //Мы можем подписаться на событие "пришло сообщение"
        //Мы не знаем, когда приидет сообщение. Но когда придет - наш код выполнится.
        //Использование ResponseRecieved находится в ClientCore.cs
        public event Action<JToken, StatusCode> ResponseRecieved;

        //Содерэит логику поиска сервера. Сервер может находиться на любом компьютере в локальной сети
        //И надо как-то выяснить, где именно. Поэтому мы опросим все комрьютеры,
        //И если на каком-то из них есть сервер, он даст о себе знать
        //Так же мы будем ждать сервер, если не можем его найти
        public void FindServer()
        {
            //Данные, которые мы будем рассылать в широковещательном UDP сообщении
            //Будем отсылвать 1 байт, просто потому что. В этом нет какой-то логики
            //Можем не отсылать данных вообще.
            //Так же в эту же переменнаю будут записаны данные, которые мы получим от сервера.
            //А именно - TCP порт сервера
            var data = new byte[] { 1 };
            //Сервер, если он есть в локальной сети, слушает UDP сообщения на 5000 порту
            //Потому мы быдем отсылать сообшение всем, на порт 5000
            var endPoint = new IPEndPoint(IPAddress.Broadcast, 5000);
            //Номер попытки нахождения сервера. То есть мы первый раз отправляем сообщение о поиске сервера
            int tryNum = 1;
            //Создаем формочку, которая будет отображать пользователю информацию, что мы 1 раз
            //Пытаемся подключиться к серверу.
            //Это нужно для того, чтобы в ситуации когда сервера нет, и мы пробуем найти его снова и снова,
            //Пользователь видел, что программа не висит, и все нормально
            var placeHolder = new PlaceHolderWrapper($"Finding server try #{tryNum}");
            //Сохдаем объект для отправки и приема данных по протоколу UDP
            //ОС сама выберет порт, на котором будет работать этот клиент, потому не передаем
            //аргументов в конструктор
            var udpClient = new UdpClient();
            //Устанавливаем, что данный клиент будет ждать сообщений только 1000 милисекунд
            //Если данных нет в течении 1000 секунд - будет брошено исключение
            //Сделано для того чтобы мы могли отослать новое сообщение, если на старое никто не ответил
            //Ведь сервер может быть запущен позже, чем клиент
            udpClient.Client.ReceiveTimeout = 1000;
            //Условно бесконечный цикл. Сам цикл будет работать вечно, но внутрянняя логика 
            //Прервет его выполнение в необходимый момент
            while (true)
            {
                //Если код внутри блока try выбросит исключение, выполнение перейдет в блок catch 
                //И мы сможем предпринять какие-то действия, обработать эту ситуацию
                //В данном случае, мы можем получить исключение времени ожидания,
                //Понять, что переходим на следующую итерацию, уведомить про это пользователя,
                //И послать новое сообщение
                try
                {
                    //Отправляем сообщение длиной в 1 байт всем пк на порт 5000
                    udpClient.Send(data, data.Length, endPoint);
                    //Ждем, когда сервер вернет нам свой порт.
                    //Если сервер прислал порт, он будет записан в массив data в виде 4-х байт
                    //В переменную endPoint запишется адресс сервера, откуда нам пришло сообщение
                    //Это и есть адрес сервера. Ведь он отправит нам ответ
                    data = udpClient.Receive(ref endPoint);
                    //заканчиваем цикл while, мы получили TCP порт, так что пора к нему присоединяться
                    break;
                }
                //В течении секунды не пришло сообщения
                catch
                {
                    //Увеличиваем счетчик попыток на 1
                    tryNum++;
                    //У нашей формы заглушки устанавливаем новый текст для отображения
                    //Так, при каждой попытке мы увидим на консоли ее номер
                    placeHolder.Content = $"Finding server try #{tryNum}";
                }
            }
            //Отчищаем UDP клиента, он нам больше не понадобится
            //метод Dispose освободит занятый порт
            udpClient.Dispose();
            //Получаем число, порт сервера, из байт, которые он нам прислал
            //Чило, а именно порт сервера, хранится в переменной типв=а int
            //Допустим, порт сервера это 5100
            //По сети могут быть переданы только байты, потому данные биты (нули и единицы)
            //Разбиваются на 4 байта. Почему 4? int занимает 32 бита
            //А один байт занимает 8 бит. Соответственно любое число типа int может быть разбито на 4 байта
            //Нам же надо склеить эти байты обратно в int переменнную
            //BitConverter умеет отдавать байты для конкретного числа и создавать число из байт.
            //Смело пользуемся им
            int targetPort = BitConverter.ToInt32(data, 0);
            //Устанавливаем соединение с сервером. его IP адрес мы получили при получении UDP сообщения
            tcpClient.Connect(endPoint.Address, targetPort);
            //Запускаем метод ListenConnectioin, этот метод будет слушать данные от сервера, и вызывать
            //Событие о том, что пришел какой-то отсет от сервера. Все, кто захотят об этом узнать - узнают
            Task.Factory.StartNew(ListenConnection);
        }


        //Отправляет на сервер любой сообщение, которое мы захотим
        public void SendMessage(Message message)
        {
            //Для передачи данных по сети мы должны C# объект преобразовать
            //В строку, которая будет передана. 
            //Строка должна быть специального формата, чтобы 
            //Принимающая сторона могла понять, какая именно информация
            //В ней сожержится. Для нашего проекта мы используем JSON
            //Метод SerializeObject сам знает, какие данные содержатся
            //В передаваемом объекте, и сам строит строку правильного формата
            var jsonString = JsonConvert.SerializeObject(message);
            //Для передачи строки по сети мы должны преобраховать ее в 
            //Набор байт. Так как по сети передаются именно байты, не смотря на
            //то, что именно они означают.
            var data = Encoding.UTF8.GetBytes(jsonString);
            //Так же мы должны узнать и записать в поток длину нашего сообщения в байтах
            //Зачем это нужно?
            //На принимающей стороне(в данном случае сервере)
            //На вход приходит строка {"field":5436}{"other":"ha ha "}
            //Он может в общем-то понять, что вот на { сообщение началось
            //И на } сообщение закончилось. Но куда проще перед каждым сообщением писать
            //Его длину. И принимающая сторона всегда сможет просто определить, где кончается 
            //Сообщение. Получается что сервер получит
            //14{"field":5436}18{"other":"ha ha "}
            //Мы же записываем количество байт, так как символ != 1 байт
            //И сервер будет читать именно столько байт, сколько надо
            //Про преобразование чисел в байты написано выше 
            var dataLength = BitConverter.GetBytes(data.Length);
            //Блокируем две операции записи в поток. Так как нам необходимо
            //Чтобы наше сообщение шло в потоке байт ровно за его длиной,
            //Нам важно, чтобы между операцией записи длины сообщения и 
            //Операцией записи самого сообщения, в поток ничего не записалось. 
            //Иначе, Если кто-то еще параллельно сможет вклиниться и вписать что-то еще
            //То сервер не сможет разобрать входные данные
            //Например такой вход - фигня какая-то
            //1418{"field":5436}{"other":"ha ha "}
            lock (sync)
            {
                //Отправляем данные из массива длины сообщения, начиная с 0 байта
                tcpClient.GetStream().Write(dataLength, 0, dataLength.Length);
                //Отправляем данные из массива данных сообщения, начиная с 0 байта
                tcpClient.GetStream().Write(data, 0, data.Length);
            }
        }

        //Метод запрашивает у сервера список пользователей онлайн
        //И возвращает его как результат
        public List<string> GetUsersList()
        {
            //ManualResetEvent - Очень удобный класс, когда в нашем текущем
            //потоке выполнения (не данных) надо сделать что-то только тогда,
            //Когда в некотором другом потоке что-то произошло
            //Так, чтение данных из сети выполняется в другом потоке, в то время
            //Как текущий поток, в котором мы сейчас находимся, хочет взять оттуда данные.
            //Принцип работы ресетИвента таков
            //В текущем потоке, который должен ждать сигнала от некого другого
            //Вызывает метод Wait()
            //Этот метод закончит выполнение тогда, когда какой-то другой поток выолнит
            //На этом ресетИвенте метод Set(), говоря о том, что первый поток может продолжить выполнение
            ManualResetEventSlim resetEvent = new ManualResetEventSlim();
            //В список names мы запишем полученные от сервера имена пользователей
            List<string> names = new List<string>();
            //Создаем лямбду, локальную функцию, кусочек кода, который должен быдет быть выполнен
            //При получении любого сообщения от сервера
            //Action<JToken, StatusCode> говорит о том, что данный кусок кода принимает
            //В себя как аргументы два объекта типов JToken и StatusCode
            //Внутри данной локальной функции они будут иметь названия  obj и statusCode
            Action<JToken, StatusCode> lamda = (obj, statusCode) =>
            //Тело локальной функции
            {
                //Нам нужно только сообщение о списке пользователей онлан
                //И мы, получая от сервера сообщения, будем игнорирывать все, код
                //Которых не равен OnlineUsers
                if (statusCode == StatusCode.OnlineUsers)
                {
                    //Сервер прислал сообщение со списком пользователей
                    //Значит в сообщении содержится объект типа OnlineUsersResponse
                    //А внутри него лежит список строк, как раз нужные нам имена
                    names = obj.ToObject<OnlineUsersResponse>().UserNames;
                    //И когда было получено данное сообщение, уведомляем ресетИвент
                    //О том, что сообщение получено и записано в переменную names
                    resetEvent.Set();
                }
            };
            //На событие получения сообщение вешаем нашу лямбду, то есть когда мы
            //В другом потоке получили некоторое сообщение, код, описанный в этой лямбде будет выполнен
            ResponseRecieved += lamda;
            //Отправляем на сервер просьбу вернуть список пользователей онлайн
            SendMessage(new OnlineUsersMessage());
            //Ожидаем вызов метода Set() из нашей лямбы.
            //То есть метод Wait() будет выполняться до тех пор, пока в переменную
            //names не запишется список пользователей, находящихся онлайн 
            resetEvent.Wait();
            //Снимаем нашу лямбду с события, нам больше не надо, чтобы при получении
            //Сообщения от сервера она выполнялась. Так что отвязываем данный код
            //От события
            ResponseRecieved -= lamda;
            //Возвращаем список пользователей онлайн, полученный от сервера
            return names;
        }
        //Возвращает объект Response, для получения первого принятого от сервера
        //Сообщения с неким статусным кодом. Используется на начальном цикле
        //Когда мы или логинимся или регистрируемся. Когда сервер доолжен прислать нам
        //Только одно сообщение, или все хорошо, или не очень хорошо 
        public Response GetResponse()
        {
            //Как в методе выше ресетивент для ожидания сообщения в другом потоке
            ManualResetEventSlim resetEvent = new ManualResetEventSlim();
            //переменная для хранения результата
            Response response = null;
            //Лямбда, которая будет выполнена при получении сообщения
            Action<JToken, StatusCode> lamda = (obj, statusCode) =>
            {
                //Любой принимаемый объект является объектом Response
                //Так что спокойно приводим полученное сообщение к этому типу
                response = obj.ToObject<Response>();
                //Оповещаем ресетивент про то, что мы получили сообщение
                resetEvent.Set();
            };
            //Вешаем эту лямбду на событие получения сообщения
            ResponseRecieved += lamda;
            //Ожидаем сообщения
            resetEvent.Wait();
            //Дождались сообщения, снимаем лямбду, нечего ее больше выполнять
            ResponseRecieved -= lamda;
            //Возвращаем роезультат, который мы считали с сервера
            return response;
        }

        //Метод, слушающий сообщения с сервера. Выполняется в отдельном потоке
        private async Task ListenConnection()
        {
            //Поток данных, которые нам шлет сервер. Сохраняем его в переменную
            //Чтобы не писать каждый раз tcpClient.GetStream()
            var stream = tcpClient.GetStream();
            //СОздаем буффер для чтения длины входящего сообщения
            //Длина входящего сообщения - 4 байта, размер, занимаемый типом int
            //Ключевое слово sizeof позволяет получить размер некого типа данных
            //В памяти. для int это 4, но для наглядности пишем sizeof
            var responseLengthBuffer = new byte[sizeof(int)];
            //буффер для считывания самого сообщения.
            //Нам будет достаточно 4096 байт для считывания любого сообщения. Это 4КБ
            //Зато мы не будем выделять память каждый раз при получении сообщения,
            //А будем использовать один и тот же буффер всегда
            var responseBuffer = new byte[4096];
            //Читаем с потока пока не запрошена остановка потока
            while(!tokenSource.Token.IsCancellationRequested)
            {
                //Читаем с сервера длину нашего сообщения, данные запишутся в нужный буффер
                //Мы говорим, что записывать надо начиная с 0-го элеимента, и записывать надо sizeof(int)
                //элементов, то есть 4
                //Так же передаем токен отмены. Так если в процессе чтения необходимо выключить поток
                //Метод ReadAsync выбросит исключение, которе уронит наш поток, чем его и завершив
                await stream.ReadAsync(responseLengthBuffer, 0, sizeof(int), tokenSource.Token);
                //Получаем из полученных 4-х байт число, длину сообщения
                var responseLength = BitConverter.ToInt32(responseLengthBuffer, 0);
                //Читаем в буффер responseLength байт, пишем с нулевого. СНова переаем токен для прерывания
                //Чтения
                await stream.ReadAsync(responseBuffer, 0, responseLength, tokenSource.Token);
                //Из нашего буффера, начиная с 0 по responseLength берем байты и конвертируем  в строку
                //Там будет строка в формате JSON. Так мы с сервером договорились
                var jsonString = Encoding.UTF8.GetString(responseBuffer, 0, responseLength);
                //Разбираем полученную строку и помещаем ее в объект типа JToken
                //Такой объект содержит в себе всю информацию, которая была в строке,
                //И в любой момент может отразить внутренние данные на любой тип из C#
                //Чем мы будем постоянно пользоваться
                //Матод ToObject<НЕОБХОДИМЫЙ ТИП>()
                var token = JToken.Parse(jsonString);
                //Вызываем событие получения сообщения, передавая наши данные, хранящиеся в JToken
                //И сразу подставляем StatusCode, для удобства обработки события при его получении кем либо
                //Вопросительный знак перед Invoke говорит о том, что метод Invoke
                //Выполнится только тогда, когда на это событие кто-то подписан. 
                //Если вызвать Invoke без этой проверки, может выпасть исключение.
                //Но только если на событие никто не подписан. 
                //В программах это бывает не часто, но лучше перестраховаться
                ResponseRecieved?.Invoke(token, GetStatusCode(token));
            }
        }
        //Метод получения StatusCode из полученных данных.
        //Просто преобразуем данные к типу Response и берем его поле  StatusCode
        private StatusCode GetStatusCode(JToken token) => token.ToObject<Response>().StatusCode;

    }
}
